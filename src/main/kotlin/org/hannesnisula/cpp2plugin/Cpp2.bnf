{
    parserClass="org.hannesnisula.cpp2plugin.parser.Cpp2Parser"
    
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    
    psiClassPrefix="Cpp2"
    psiImplClassSuffix="Impl"
    psiPackage="org.hannesnisula.cpp2plugin.psi"
    psiImplPackage="org.hannesnisula.cpp2plugin.psi.impl"
    
    elementTypeHolderClass="org.hannesnisula.cpp2plugin.psi.Cpp2Types"
    elementTypeClass="org.hannesnisula.cpp2plugin.psi.Cpp2ElementType"
    tokenTypeClass="org.hannesnisula.cpp2plugin.psi.Cpp2TokenType"
    
    extends(".*expr")=expr
    
    tokens=[
        ARROW               = '->'
        COLONCOLON          = '::'
        DOTDOTDOT           = '...'
        PLUSPLUS            = '++'
        MINUSMINUS          = '--'
        OROR                = '||'
        ANDAND              = '&&'
        EQEQ                = '=='
        NEQ                 = '!='
        LTEQ                = '<='
        GTEQ                = '>='
        LTLT                = '<<'
        GTGT                = '>>'
        
        COLON               = ':'
        SEMICOLON           = ';'
        LEFT_BRACE          = '{'
        RIGHT_BRACE         = '}'
        LEFT_PARENTHESIS    = '('
        RIGHT_PARENTHESIS   = ')'
        LT                  = '<'
        GT                  = '>'
        EQ                  = '='
        UNDERSCORE          = '_'
        ASTERISK            = '*'
        PLUS                = '+'
        MINUS               = '-'
        SLASH               = '/'
        MODULO              = '%'
        AND                 = '&'
        OR                  = '|'
        EXP                 = '^'
        
        FOR                 = 'for'
        DO                  = 'do'
        IN                  = 'in'
        COPY                = 'copy'
        INOUT               = 'inout'
        OUT                 = 'out'
        MOVE                = 'move'
        FORWARD             = 'forward'
        
        RETURN              = 'return'
    ]
}

file ::= (stmt | named_decl | for_loop | COMMENT)*

stmt_block ::= '{' (stmt | COMMENT)* '}'
stmt ::= (named_decl | assign | return_expr) ";" {
    pin=1
}

named_decl ::= IDENTIFIER_WORD decl
decl ::= func_decl | var_decl

func_decl ::= ':' func_expr
func_expr ::= func_signature '=' (stmt | stmt_block) {extends=expr}
func_signature ::= func_params ('->' id)?
func_params ::= '(' param_decl* ')'
func_call ::= (id | type_id_scoped) '(' (expr)* ')' {extends=expr} // TODO: Investigate its correctness
arg ::= param_kind? id
param_decl ::= param_kind? IDENTIFIER_WORD // TODO: [HERE] what are the valid param declarations? type (colon) required?
param_kind ::= ('in' | 'copy' | 'inout' | 'out' | 'move' | 'forward')

var_decl ::= (':' type_specifier ('=' expr)?) | (':' '=' expr)

// OLD ---------------------------------
for_loop ::= 'for' id 'do' '(' arg* ')' (stmt_block) {
    pin=1
}

return_expr ::= RETURN expr

assign ::= id '=' expr {rightAssociative=true}
//decl ::= IDENTIFIER_WORD ':' (type_specifier | '_' | func_params)? ('=' expr)?
//var_decl ::= IDENTIFIER_WORD ':' type_specifier !'='

id ::= scope? IDENTIFIER_WORD ('[' expr ']')? {extends=expr}
literal ::= NUMBER_LITERAL | STRING_LITERAL {extends=expr}

type_specifier ::= (const | '*')*  type_id_scoped
type_id_scoped ::= scope? type_id
scope ::= (type_id '::')+
type_id ::= IDENTIFIER_WORD template_def?

template_def ::= '<' (type_id_scoped | id | NUMBER_LITERAL | STRING_LITERAL)* '>'
template_decl ::= '<' template_param_decl+ '>'
template_param_decl ::= IDENTIFIER_WORD '...'? (':' IDENTIFIER_WORD)?

expr ::= group_14_expr | group_13_expr | group_12_expr | group_11_expr | group_10_expr | group_9_expr | group_8_expr | group_7_expr | group_6_expr | group_5_expr | group_2_expr | id | func_expr | literal

private group_14_expr   ::= or_expr
private group_13_expr   ::= and_expr
private group_12_expr   ::= bit_or_expr
private group_11_expr   ::= bit_xor_expr
private group_10_expr   ::= bit_and_expr
private group_9_expr    ::= eq_expr | neq_expr
private group_8_expr    ::= lt_expr | gt_expr | lteq_expr | gteq_expr
private group_7_expr    ::= left_shift_expr | right_shift_expr
private group_6_expr    ::= add_expr | sub_expr
private group_5_expr    ::= mul_expr | div_expr | mod_expr
private group_2_expr    ::= func_call

or_expr             ::= expr '||'   expr {rightAssociative=false}
and_expr            ::= expr '&&'   expr {rightAssociative=false}
bit_or_expr         ::= expr '|'    expr {rightAssociative=false}
bit_xor_expr        ::= expr '^'    expr {rightAssociative=false}
bit_and_expr        ::= expr '&'    expr {rightAssociative=false}
eq_expr             ::= expr '=='   expr {rightAssociative=false}
neq_expr            ::= expr '!='   expr {rightAssociative=false}
lteq_expr           ::= expr '<='   expr {rightAssociative=false}
gteq_expr           ::= expr '>='   expr {rightAssociative=false}
lt_expr             ::= expr '<'    expr {rightAssociative=false}
gt_expr             ::= expr '>'    expr {rightAssociative=false}
right_shift_expr    ::= expr '>>'   expr {rightAssociative=false}
left_shift_expr     ::= expr '<<'   expr {rightAssociative=false}
add_expr            ::= expr '+'    expr {rightAssociative=false}
sub_expr            ::= expr '-'    expr {rightAssociative=false}
mul_expr            ::= expr '*'    expr {rightAssociative=false}
div_expr            ::= expr '/'    expr {rightAssociative=false}
mod_expr            ::= expr '%'    expr {rightAssociative=false}

//private Recovery ::= !(Identifier | NUMBER_LITERAL)