{
    parserClass="org.hannesnisula.cpp2plugin.parser.Cpp2Parser"
    
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    
    psiClassPrefix="Cpp2"
    psiImplClassSuffix="Impl"
    psiPackage="org.hannesnisula.cpp2plugin.psi"
    psiImplPackage="org.hannesnisula.cpp2plugin.psi.impl"
    
    elementTypeHolderClass="org.hannesnisula.cpp2plugin.psi.Cpp2Types"
    elementTypeClass="org.hannesnisula.cpp2plugin.psi.Cpp2ElementType"
    tokenTypeClass="org.hannesnisula.cpp2plugin.psi.Cpp2TokenType"
    
    tokens=[
        ARROW               = '->'
        COLONCOLON          = '::'
        DOTDOTDOT           = '...'
        
        COLON               = ':'
        SEMICOLON           = ';'
        LEFT_BRACE          = '{'
        RIGHT_BRACE         = '}'
        LEFT_PARENTHESIS    = '('
        RIGHT_PARENTHESIS   = ')'
        LT                  = '<'
        GT                  = '>'
        EQ                  = '='
        UNDERSCORE          = '_'
        ASTERISK            = '*'
        
        FOR                 = 'for'
        DO                  = 'do'
        IN                  = 'in'
        COPY                = 'copy'
        INOUT               = 'inout'
        OUT                 = 'out'
        MOVE                = 'move'
        FORWARD             = 'forward'
    ]
}

File ::= (Statement | FunctionDefinition | ForLoop | COMMENT)*

ForLoop ::= 'for' Identifier 'do' '(' Argument* ')' (StatementBlock) {
    pin=1
}

FunctionDefinition ::= '(' ParameterDeclaration* ')' ('->' ('_' | TypeSpecifier))? '=' (Statement | StatementBlock)

StatementBlock ::= '{' (Statement | COMMENT)* '}'
Statement ::= (VarDeclaration | VarDefinition | VarAssignment | ReturnExpression) ";" {
    pin=1
}

ReturnExpression ::= RETURN Expression

Argument ::= ParameterKind? Identifier

ParameterDeclaration ::= ParameterKind? VarDeclaration
ParameterKind ::= ('in' | 'copy' | 'inout' | 'out' | 'move' | 'forward')

VarAssignment ::= Identifier '=' Expression
VarDefinition ::= IDENTIFIER_WORD ':' TypeSpecifier? '=' Expression
VarDeclaration ::= IDENTIFIER_WORD ':' TypeSpecifier !'='
TypeSpecifier ::= (const | '*')*  Scope? TypeIdentifier

Expression ::= Identifier | NUMBER_LITERAL | STRING_LITERAL

Identifier ::= Scope? IDENTIFIER_WORD ('[' Expression ']')?

Scope ::= (TypeIdentifier '::')+
TypeIdentifier ::= IDENTIFIER_WORD TemplateDefinition?

TemplateDefinition ::= '<' (IDENTIFIER_WORD | NUMBER_LITERAL | STRING_LITERAL)* '>'
TemplateDeclaration ::= '<' TemplateParamDeclaration+ '>'
TemplateParamDeclaration ::= IDENTIFIER_WORD '...'? (':' IDENTIFIER_WORD)?

//private Recovery ::= !(Identifier | NUMBER_LITERAL)